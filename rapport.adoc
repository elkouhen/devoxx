= Devoxx 2016
Mehdi EL KOUHEN <mehdi.elkouhen@softeam.fr>
:doctype: article
:source-highlighter: coderay
:listing-caption: Listing
:encode: UTF-8
:toc:
// Uncomment next line to set page size (default is Letter)
//:pdf-page-size: A4


== Test driven infrastructure avec Docker

http://github.com/WeScale/salt-docker-integration

Saltstack : similaire à ansible, YAML pour décrire le provisionning

* Provisionning orienté rôle : exemple associer le rôle redis à une machine pour installer redis sur la machine

Comment tester automatiquement ses scripts de provisionning ?

*Méthodologie initiale :*

* lancer le provisonning
* 2 à 3 minutes pour reboot et provisionning

=> Trop long

*Solution :*

* provisionning de conteneurs docker (salt, chef, etc.)
* rajout d'assertions pour tester le système

*Conception du framework de test*

* Fichier de rôles
* Fichier asserts
* Fichier grains (pour spécialiser les machine i.e. affecter rôle et donc installer quelque chose sur la machine)

*Solution finale*

* Provisionning du master
* Provisionning du minion
* Application du provisionning du minion via le master

*Limitations :*

* pas de gestion de la conf réseau
* pas de formattage disque

=> Il faut aussi exécuter les tests sur des vraies machines

== Apache maven, Java 9 et Jigsaw

Evolutions java 9 impactantes :

* D'après java -version, le binaire est tjs du java 8 => mais StringConcatFactory not found
* JEP 223 : gestion des version (majeur.mineur.security)
* JEP 261 : support des modules
* JEP 247 : compile pour différentes versions de java (notamment compiler avec java 9 en utiliser le rt.jar java 8)
* JEP 238 :

Statut

* maven 3 fonctionne
* attention aux version des plugins utilisées

== Apache Drill

Permet de faire du SQL sur plein de bases de données (CSV, JSON, MongoDB, SQL, ...)

Dans un projet BigData il y'a 4 Phases

* Ingestion des données
* Stockage (file systeme, etc...)
* Traitement (Spark)
* Consommation dans les applications (SQL)

De plus en plus de données sont non structurées

* intéressant de consommer en SQL parce qu'a la fin on tombe sur du reporting (qlickview, tableau, excel)

Dans Drill, définition du schéma à la volée (Drill essaie de deviner)

[source]
select * from dfs.yelp.`business.json`
	      plugin à utiliser - schéma ou workspace - le fichier ou la table

Drill est orienté big data

* distribution d'un fichier sur plein de noeuds avant de requêter

Drill apporte des extension à SQL pour gérer les structures hiérarchiques de JSON

[source]
exemple select name, stars, b.hours.Friday friday FROM ...

Drill fournit des opérateur de mise à plat de liste pour tomber sur du SQL normalisé

Drill permet de stockage de données intermédiaires via parquet (format de fichier optimisé pour le requêtage)

Drill permet de faire des jointures entre données stockées dans des sources différentes (fichier + mongo)

== ES6

ES3 utilisé pour pré IE 9

ES5 utilisé pour IE9+

Prise en charge native

* Navigateurs evergreen 90% a 98%
* Safari 53% (bridage volontaire)
* Node 4.43 48% 5,10 58% et Node LTS 6 96%

Sinon on peut transpiler du code ES6 -> ES5 avec Babel

Babel est utilisé pour tout le code de facebook

* Possibilité de configurer ce qui est transpilé (en fonction de la cible)

=== Nouveautés ES6

* Litteraux objet { type : coco, id, text}
* Mot clefs : class, extends, constructor, super
* Accesseurs transparents get et set en prefix
* Variables statiques : static
* Destructuration
** piocher dans des objets structurés { x } = mavariable
** paramètre de fonctions
** gestion des tableaux
* Rest & spread
* Valeurs par défaut
* Template String ` ${person.age} `
* Let et const pour remplacer var (scope fonction)
* Littéraux étendus : octaux binaires unicode
* Fonctions flechees
* Module :
** export
** import
** Chargement dynamique via System.import
* Promesses en natif : standard A+
** async (fonction déclarée asynchrone) / await (appel en synchrone)
* Meta programmation
** Proxy
* Décorateurs
** composants d'ordre supérieur

=> lebab pour transformer du ES5 vers ES6

== Unikernel The Future of Containers

Archi docker : OS host + Daemon docker + conteneur docker

MirageOS (projet Xen) : OS pour packager les applications sur unikernel

Constat : pour développer un routeur je n'ai pas besoin d'un kernel avec un driver de disque

* 1ere idée : modulariser l'OS et ne prendre dans le conteneur que le strict nécessaire
* 2nde idée :
** appli en caml ou la définition du module abstrait les composants systèmes utilisés
** ensuite on build l'appli en fonction de la cible
** production d'une machine virtuelle xen ne contenant que les composants nécessaires

== Clever Cloud - IT Automation

Attention a l'utilisation de conteneurs docker différents de la cible

-> risques de sécurité (exemple docker qui à une glibc différente à celle de la machine host)
-> mieux de ne pas mixer les distribs

== Vert.x

Librairie pour construire des applications réactives

* event driven
* non blocking
* event loop
* polyglotte

Ne jamais bloquer l'event loop

* worker thread pool pour appeler du code bloquant

Event bus (distribué)

* publish - subscribe
* point 2 point
* request - response

== Service discovery

Service ? -> adresse IP et port

Types d'enregistrements DNS

* *Type A* 1 adresse IP v4
* *Type AAAA* 1 adresse IP v6
* *Type SRV* n adresses IP port (avec une gestion de priorité)

Histoire archi logicielle

* Monolithique (EJB, JNDI) -> non scalable
* SOA / Micro services -> service déployés sur n serveurs

Histoire archi physique

* avant serveur physique
* maintenant 1 service par VM ou conteneur (-> on multiplie les services et ports)
* On déploie aussi sur le cloud
** a chaque redémarrage d'un VM elle peut changer d'adresse IP

SDP Service discovery protocol : annuaire 1 nom de service -> IP + port

=== Exemple de solutions

* zookeeeper
* etcd
* eureka
* consul

Zookeper & etcd basé sur un key value distribué

=== Consul

* contient un key value distribué
* 2 types d'agents
** 1 agent serveur
** 1 agent client pour s'enregistrer du client au serveur

*Caractéristiques du Client :*

* forward des requetes au service
* gestion du healthcheck
* stateless

Chaque agent client s'enregistre au niveau des agent serveur

* API rest pour obtenir des infos sur un service en particulier
* infos aussi disponibles dans le DNS

Consul fourni un outil consul-template pour générer la conf haproxy automatiquement

* On peut enregistrer/desenregistrer un service via une API http

*Conseils*

* 3 ou 5 master
* créer un user spécifique pour consul
* spécialiser les agents
* gérer les mots de passe avec vault
* intégrer avec un orchestrateur (messo, nomad, ...)

== De angular 1 -> angular 2

Différences
- langage javascript -> typescript
- MV* -> Composant
- databinding bidirectionnel -> unidirectionnel

Bonnes pratiques ?

* organiser en modules fonctionnels
* fini les factory -> utiliser service (fonction constructrices)
* utiliser controllerAs (bannir $scope) (a faire à la définition du contrôleur) -> éviter l'héritage par prototype de scope
* angular 1.5 apporte les composants (tout doit devenir composant)
* routing ?
** le routeur angular2 a été backporté vers angular 1
* système de module : solution systemJS (polyfill ES6 utilisé par angular)
* JSPM à la place de NPM (+ général que npm , bien intégré à systemjs)
* typescript (compatible js, typage structurel, type wildcard : any)
* bootstrapper l'application avec System.import & appel de angular.bootstrap au lieu de ng-app
* remplacer $scope.watch par les getters et setters

angular 2 fournit une API pour mixer du angular 1 et angular2
-> le noeud racine reste un noeud angular1

=> upgradeadapter pour bootstrapper l'application

=> on downgrade les composants angular2 en angular 1 pour les utiliser dans des composants angular 1
=> on upgrade les composants angular 1 en angular 2 pour les utiliser dans des composants angular 2

ng-forward permet d'utiliser les décorateurs angular 2 en angular 1

== Loop

Objectif : industrialiser le workflow de développement

Agnostique aux technos utilisés

Dans un script devloop.js

* on indique la liste des "composants" de l'appli
* on indique comment les compiler et les démarrer
* on indique quand les compiler

== Asciidoctor

*Killer Feature :* inclusion de portions de fichiers (via des tag begin et end)

plugin chrome pour voir les fichiers asciidoctor

gitlab gère asciidoctor

== Spring Cloud *

Besoin (-> 12factor.net) :

* Service Registry
* Configuration

*Service Registry*

* @EnableDiscoveryClient
* discoveryClient.choose("serviceId") -> {host, port}
* RestTemplate (pas besoin de mettre le hote et port mais le nom du service)
* @FeinClient : client déclaratif

*Config*

* @ConfigurationProperties (reloadable), @Value, Environment

*Spring Cloud Config Server*

* similaire à celui de netflix
* ptés dans GIT, SVN
* @RefreshScope pour le rechargement des beans après modif des propriétés
* Webhooks support for github, gitlab and bitbucket
* gestion de propriétés globales + par projet

*Service Discovery*

* Netflix (trop orienté java, mature, mise à jour longues -> jusqu'à 90 s)
* Consul
** service discovery & configuration, polyglot, HTTP API and DNS, ACLs, Health Checks, multi datacenter, Vault
** young, agent on every host
* Zookeeper
** Consistent Store, mature,
** scaling, difficile pour les OPS,

== HTTPS

HTTP dans une session SSL/TLS

*	google prefere https pour SEO
* firefox et chrome bloquent certaines api javascript hots https (geolocation, ...)
*	HTTP/2 ne fonctionne qu'en HTTPS

Pourquoi ?

* Confidentialité
* Authentification
* Intégrité
* Transparence
* Spontanéité

*Chiffrement symétrique*

* On chiffre et déchiffre en utilisant la même clef

*Chiffrement asymétrique*

* Une clef (privée) pour chiffrer et clef (publique) pour déchiffrer
** moins performant que le chiffrement symétrique

*Fonction de hashage*

HMAC : fonction de hashage influencée par une clef

*Signature numérique d'un document*

Chiffrement du résultat du hashage appliquée au document

*Poignée de main*

-> Client Hello (contient la version max TLS 1.2, Session ID, Liste Algorithmes ordonnées de chiffrement supportés, SNI Serveur Name Indication)
<- Serveur hello (version de TLS, Session ID, Algorithme de Chiffrement utilisé, Certificat au format X509)
-> Choix un nombre

Diffie

*3 types de certificats*

* domaine validation (propriétaire d'un domaine)
* organisation validation (vérification de l'info)
* extended validation (enquete)

Lets encrypt : autorité de certification, protocole ACME + Agent

*Révocation*

* *CRL :* liste de certificats invalide dans le certificat racine
* *OCSP :* réponse par authorité de certification
* *OSCP Stampling :* le serveur joint une preuve valable quelque minutes
* *CRLSet :*

== Nouveautés CDI 2.0

CDI 2.0 : JSR 365

* Weld 3 implémentation de référence
* cdi-spec.org

New Features :

* support des évènements asynchrones
* annotation startup (pas encore fait, mais possible via utilisation d'un observer)
* faire du CDI en dehors de Java EE
* AOP pour custom beans (pas fini)
* support de la sécurité (sorti dans une autre spec)
* ordonnancement des observateurs

== Jigsaw

Problèmes

* JAR Hell :
** une appli utilise 2 librairies asm 2.3 et asm 3.1
** au démarrage de l'application scan linéaire pour trouver une classe : une classe asm 3.1 peut hériter d'une classe d'asm 2.3
** On veut Fidélité Compilation ~ Exécution

* java c'est gros
** rt.jar 66 Mb
*** Spring Context 1.1 Mb

* Sécurité
** Les classes de rt.jar sont privilégiées (souci de sécurité)
** Java n'a qu'un seul mur de sécurité. Dès qu'on le traverse, ...

Les modules sont une réponse à ces soucis
* packages importés, exportés, cachés

Jigsaw a des contraintes

* il faut que les builds avec maven gradle fonctionnent
* on veut que les applications jboss module, osgi, java ee fonctionne encore avec jigsaw

Jigsawifier ?

* outils : jdeps permet de déterminer les dépendances d'un package
* on commence par déclarer les modules (fichier module-info.java)

[source]
module fr.drgaon.rt{
	requires java.base
	export fr.////
}

-> contrairement à OSGi on ne met pas les numéros de version dans module-info.java

javac prend en paramètre un modulepath et un classpath

* les modules dans modulepath ne voit pas le classpath

Modules automatiques : la plateforme construit le module-info automatiquement

Le nom du module est inféré à partir du nom du jar

A la création d'un jar, on peux rajouter des meta infos (exemple: module-version, main-class)

Les requires ne sont pas transitifs

Il existe le require public (transitif à un saut)

On peut restreindre les exports de package

[source]
exports com.softeam to fr.uml.dragon.ast

-> permet d'empêcher l'utilisation sun.misc.Unsafe

Module Service pour découpler l'interface de son implémentation

[source]
consomme
uses fr.uml.dragon.

[source]
fournisseur
provides fr.kkkk to fr.uml

On démarre maintenant le module à démarrer

jlink pour générer un executable pour une architecture cible (ARM)
